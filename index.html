<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Royal Game of Ur</title>
  <!-- Dummy favicon to prevent 404 -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fafafa;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    #gameContainer {
      position: relative;
      width: 1020px; /* Container to hold the 1000×600 canvas + some padding */
      max-width: 100%;
      padding: 20px;
      box-sizing: border-box;
      background: #fff;
      margin-bottom: 20px;
      border: 2px solid #ccc;
      border-radius: 4px;
    }
    canvas {
      display: block;
      background: #ddd;
      margin: auto; /* center the canvas within the container */
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button,
    #controls input {
      font-size: 16px;
      padding: 6px 10px;
      margin: 4px;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 10;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* Loading overlay */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Logo in bottom-right */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- MENU SCREEN -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Another Product Invented<br>Royal Game of Ur</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>How to Play</strong></p>
    <p>
      The board is based on a 3×8 grid with gaps so that only 20 squares exist.
      Some squares are marked as <em>rosettes</em> (they get a fancy star design).
      On your turn, roll four binary dice (0–4) and move one of your 7 pieces forward.
    </p>
    <p>
      Landing on a rosette grants an extra turn. You cannot capture an opponent on a rosette,
      and you must have an exact roll to exit the board.
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- SIDE SELECTION SCREEN -->
  <div id="sideScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White (Go First) [W]</button>
    <button id="blackSideBtn">Black (Go Second) [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Canvas for the board -->
  <!-- Now 1000×600, with smaller squares so there's plenty of space around. -->
  <canvas id="gameCanvas" width="1000" height="600"></canvas>
</div>

<!-- Controls below the game container -->
<div id="controls">
  <button id="rollDiceBtn">Roll Dice</button>
  <label for="customDiceInput">Custom Dice:</label>
  <input type="number" id="customDiceInput" min="0" max="4" value="0">
  <button id="setCustomDiceBtn">Set Dice</button>
  <!-- Display counts of off-board pieces -->
  <div id="pieceCountDisplay" style="margin-top:8px; font-size:16px;"></div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Thinking...</p>
</div>

<!-- Optional Logo -->
<img id="logo" src="logo.png" alt="Logo">

<script>
  /***** Global Setup *****/
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const canvasWidth = canvas.width;   // 1000
  const canvasHeight = canvas.height; // 600

  // *** We now use smaller squares: 50×50
  const SQUARE_SIZE = 50;

  // The board is 8 columns wide => 8×50 = 400px, and 3 rows tall => 3×50 = 150px
  // We do skip columns in row 0 & 2, but total bounding box is 400×150
  // We'll center that in a 1000×600 canvas.
  const boardWidth = 400;
  const boardHeight = 150;

  // Margin offsets to center the board.
  const boardMarginX = (canvasWidth - boardWidth) / 2;  // e.g. (1000 - 400)/2 = 300
  const boardMarginY = (canvasHeight - boardHeight) / 2; // e.g. (600 - 150)/2 = 225

  /***** Board Layout *****
    3×8 grid with some gaps => 20 squares total
    Row 0: "1", "rosette", gap, gap, "1", "1", "1", "rosette"
    Row 1: all 8 columns, col4 is rosette
    Row 2: same pattern as row0
  *****/
  const boardSquares = [
    // Row 0 (y = 0)
    { x: 0,   y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // index 0
    { x: 50,  y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // index 1
    // columns 2,3 => gap => next square at col4 => x= 4*50=200
    { x: 200, y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // index 2
    { x: 250, y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // index 3
    { x: 300, y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // index 4
    { x: 350, y: 0,   w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // index 5

    // Row 1 (y=50) => 8 columns from x=0..350
    { x: 0,   y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // index 6
    { x: 50,  y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 7
    { x: 100, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 8
    { x: 150, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 9
    { x: 200, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // 10
    { x: 250, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 11
    { x: 300, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 12
    { x: 350, y: 50,  w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 13

    // Row 2 (y=100)
    { x: 0,   y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 14
    { x: 50,  y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // 15
    // columns 2,3 => gap => next square at col4 => x=200
    { x: 200, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 16
    { x: 250, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 17
    { x: 300, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // 18
    { x: 350, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }  // 19
  ];

  /***** Game State Variables *****/
  let gameState = "menu"; // "menu", "instructions", "selectSide", "playing", "gameover"
  let humanColor = null;  // "w" or "b"
  let currentTurn = null; // "w" or "b" (White always starts)
  let currentDiceRoll = 0;
  let diceRolled = false;
  let extraTurn = false;
  let aiThinking = false;
  const debugMode = true;

  const NUM_PIECES = 7;
  let whitePieces = [];
  let blackPieces = [];

  function initPieces() {
    whitePieces = Array(NUM_PIECES).fill(-1);
    blackPieces = Array(NUM_PIECES).fill(-1);
  }

  /***** Utility & Debug *****/
  function rollDice() {
    let total = 0;
    for (let i = 0; i < 4; i++){
      total += Math.floor(Math.random() * 2);
    }
    return total;
  }

  function checkForBugs() {
    function checkOverlap(pieces, color) {
      const counts = {};
      pieces.forEach(pos => {
        if (pos >= 0 && pos < 20) {
          counts[pos] = (counts[pos] || 0) + 1;
          if (counts[pos] > 1) {
            console.error(`Overlap bug: ${color} has multiple pieces on square #${pos}`);
          }
        }
      });
    }
    checkOverlap(whitePieces, "White");
    checkOverlap(blackPieces, "Black");
  }

  /***** Drawing *****/
  function drawBoard() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    boardSquares.forEach((sq, i) => {
      if (!isFinite(sq.w)) sq.w = SQUARE_SIZE;
      if (!isFinite(sq.h)) sq.h = SQUARE_SIZE;

      // Place squares in the center region:
      let drawX = sq.x + boardMarginX;
      let drawY = sq.y + boardMarginY;

      // Linear gradient from top-left to bottom-right
      let grad = ctx.createLinearGradient(drawX, drawY, drawX + sq.w, drawY + sq.h);
      grad.addColorStop(0, "#e6c87d");
      grad.addColorStop(1, "#4e6fa3");

      ctx.fillStyle = grad;
      ctx.fillRect(drawX, drawY, sq.w, sq.h);
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(drawX, drawY, sq.w, sq.h);

      if (sq.rosette) {
        ctx.save();
        ctx.translate(drawX + sq.w/2, drawY + sq.h/2);
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI*2);
        ctx.fillStyle = "red";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let arm=0; arm<8; arm++){
          ctx.moveTo(0,0);
          let angle = (Math.PI*2)*(arm/8);
          ctx.lineTo(Math.cos(angle)*10, Math.sin(angle)*10);
        }
        ctx.stroke();
        ctx.restore();
      }
    });
  }

  function drawPieces() {
    // White pieces
    whitePieces.forEach(pos => {
      if (pos < 0 || pos >= 20) return;
      let sq = boardSquares[pos];
      let cx = sq.x + boardMarginX + sq.w/2;
      let cy = sq.y + boardMarginY + sq.h/2;
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      let grad = ctx.createRadialGradient(cx-5, cy-5, 5, cx, cy, 18);
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(1, "#d0d0d0");
      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    });
    // Black pieces
    blackPieces.forEach(pos => {
      if (pos < 0 || pos >= 20) return;
      let sq = boardSquares[pos];
      let cx = sq.x + boardMarginX + sq.w/2;
      let cy = sq.y + boardMarginY + sq.h/2;
      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
      let grad = ctx.createRadialGradient(cx-5, cy-5, 5, cx, cy, 18);
      grad.addColorStop(0, "#666666");
      grad.addColorStop(1, "#000000");
      ctx.beginPath();
      ctx.arc(cx, cy, 18, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawUI() {
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, canvasHeight-30, canvasWidth, 30);
    ctx.fillStyle = "#000";
    ctx.font = "16px sans-serif";
    let txt = `Turn: ${currentTurn==="w"?"White":"Black"}. `;
    if (currentTurn===humanColor && !diceRolled) {
      txt += "Click 'Roll Dice' or press [R]. ";
    } else if (diceRolled) {
      txt += `Dice: ${currentDiceRoll}. `;
    }
    const whiteOff = whitePieces.filter(p=>p===-1).length;
    const blackOff = blackPieces.filter(p=>p===-1).length;
    txt += `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
    ctx.fillText(txt, 10, canvasHeight-10);
  }

  function redrawPlayScreen() {
    drawBoard();
    drawPieces();
    drawUI();
  }

  /***** Game Logic *****/
  function getValidMove(piecePos, diceValue, ownPieces, oppPieces) {
    if (diceValue===0) return null;
    let newPos = (piecePos===-1)?0:piecePos+diceValue;
    if (newPos>20) return null;
    if (newPos<20 && ownPieces.includes(newPos)) return null;
    if (newPos<20 && oppPieces.includes(newPos)) {
      if (boardSquares[newPos].rosette) return null;
    }
    return newPos;
  }
  function getMoveOptions(diceValue) {
    let opts=[];
    if (currentTurn==="w") {
      whitePieces.forEach((pos,i)=>{
        let t = getValidMove(pos,diceValue,whitePieces,blackPieces);
        if (t!==null) opts.push({pieceIndex:i,newPos:t});
      });
    } else {
      blackPieces.forEach((pos,i)=>{
        let t = getValidMove(pos,diceValue,blackPieces,whitePieces);
        if (t!==null) opts.push({pieceIndex:i,newPos:t});
      });
    }
    return opts;
  }
  function executeMove(pieceIndex, targetPos) {
    try {
      let own = (currentTurn==="w")?whitePieces:blackPieces;
      let opp = (currentTurn==="w")?blackPieces:whitePieces;
      own[pieceIndex]=targetPos;
      if (targetPos<20) {
        let oppIdx=opp.indexOf(targetPos);
        if (oppIdx!==-1) {
          opp[oppIdx]=-1;
          if(debugMode) console.log(`${currentTurn==="w"?"White":"Black"} captured an opponent on #${targetPos}`);
        }
      }
      if(debugMode) checkForBugs();
      if(targetPos<20 && boardSquares[targetPos].rosette) extraTurn=true; else extraTurn=false;
      let finished=own.filter(p=>p===20).length;
      if(finished===NUM_PIECES) {
        gameState="gameover";
        document.getElementById("gameOverText").textContent=(currentTurn===humanColor)?"You Win!":"You Lose!";
      }
      if(!extraTurn && gameState==="playing") currentTurn=(currentTurn==="w")?"b":"w";
      diceRolled=false; currentDiceRoll=0;
    } catch(err) {
      console.error("Error in executeMove:",err);
    }
  }
  function handleBoardClick(e) {
    if(gameState!=="playing")return;
    if(currentTurn!==humanColor)return;
    if(!diceRolled)return;
    let rect=canvas.getBoundingClientRect();
    let mx=e.clientX-rect.left,my=e.clientY-rect.top;
    let own=(currentTurn==="w")?whitePieces:blackPieces;
    for(let i=0;i<own.length;i++){
      let pos=own[i];
      if(pos<0||pos>=20)continue;
      let sq=boardSquares[pos];
      let cx=sq.x+boardMarginX+sq.w/2, cy=sq.y+boardMarginY+sq.h/2;
      let dx=mx-cx,dy=my-cy;
      if(Math.sqrt(dx*dx+dy*dy)<=18) {
        let moves=getMoveOptions(currentDiceRoll);
        let m=moves.find(x=>x.pieceIndex===i);
        if(m) {executeMove(i,m.newPos);redrawPlayScreen();return;}
      }
    }
  }
  function humanRollDice() {
    if(gameState!=="playing")return;
    if(currentTurn!==humanColor)return;
    if(diceRolled)return;
    currentDiceRoll=rollDice();
    diceRolled=true;
    if(debugMode) console.log(`Human rolled: ${currentDiceRoll}`);
    let moves=getMoveOptions(currentDiceRoll);
    if(moves.length===0) {
      diceRolled=false; currentDiceRoll=0;
      currentTurn=(currentTurn==="w")?"b":"w";
    }
    redrawPlayScreen();
  }
  function aiMove() {
    if(gameState!=="playing")return;
    if(currentTurn===humanColor)return;
    aiThinking=true;
    document.getElementById("loadingOverlay").style.display="flex";
    setTimeout(()=>{
      currentDiceRoll=rollDice();
      diceRolled=true;
      if(debugMode) console.log(`AI (${currentTurn==="w"?"White":"Black"}) rolled: ${currentDiceRoll}`);
      let moves=getMoveOptions(currentDiceRoll);
      if(moves.length>0) {
        let pick=moves[Math.floor(Math.random()*moves.length)];
        executeMove(pick.pieceIndex,pick.newPos);
      } else {
        diceRolled=false; currentDiceRoll=0;
        currentTurn=(currentTurn==="w")?"b":"w";
      }
      aiThinking=false;
      document.getElementById("loadingOverlay").style.display="none";
      redrawPlayScreen();
    },1500);
  }
  function mainLoop() {
    if(gameState==="playing") {
      redrawPlayScreen();
      if(currentTurn===humanColor && !diceRolled) {
        document.getElementById("rollDiceBtn").style.display="inline-block";
      } else {
        document.getElementById("rollDiceBtn").style.display="none";
      }
      if(currentTurn!==humanColor && !diceRolled && !aiThinking) {
        aiMove();
      }
      const whiteOff=whitePieces.filter(p=>p===-1).length;
      const blackOff=blackPieces.filter(p=>p===-1).length;
      document.getElementById("pieceCountDisplay").textContent=`White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
    }
    requestAnimationFrame(mainLoop);
  }

  /***** Overlays & Navigation *****/
  function hideAllScreens(){
    document.getElementById("menuScreen").style.display="none";
    document.getElementById("instructionsScreen").style.display="none";
    document.getElementById("sideScreen").style.display="none";
    document.getElementById("gameOverScreen").style.display="none";
  }
  function showMenu(){
    hideAllScreens(); gameState="menu";
    document.getElementById("menuScreen").style.display="flex";
  }
  function showInstructions(){
    hideAllScreens(); gameState="instructions";
    document.getElementById("instructionsScreen").style.display="flex";
  }
  function showSideSelect(){
    hideAllScreens(); gameState="selectSide";
    document.getElementById("sideScreen").style.display="flex";
  }
  function startPlaying(){
    hideAllScreens(); gameState="playing";
    initPieces(); currentTurn="w";
    diceRolled=false; currentDiceRoll=0; extraTurn=false;
  }
  function showGameOver(){
    hideAllScreens(); gameState="gameover";
    document.getElementById("gameOverScreen").style.display="flex";
  }

  document.getElementById("newGameBtn").onclick=()=>showSideSelect();
  document.getElementById("instructionsBtn").onclick=()=>showInstructions();
  document.getElementById("whiteSideBtn").onclick=()=>{humanColor="w";startPlaying();};
  document.getElementById("blackSideBtn").onclick=()=>{humanColor="b";startPlaying();};
  document.getElementById("gameOverNewGameBtn").onclick=()=>showSideSelect();
  document.getElementById("rollDiceBtn").addEventListener("click",humanRollDice);
  
  // Custom dice for testing
  document.getElementById("setCustomDiceBtn").addEventListener("click",()=>{
    const val=parseInt(document.getElementById("customDiceInput").value,10);
    if(!isNaN(val)&&val>=0&&val<=4){
      currentDiceRoll=val; diceRolled=true;
      if(debugMode)console.log(`Custom dice set to: ${currentDiceRoll}`);
      redrawPlayScreen();
    }
  });
  document.addEventListener("keydown",e=>{
    const key=e.key.toLowerCase();
    if(gameState==="selectSide"){
      if(key==="w")document.getElementById("whiteSideBtn").click();
      else if(key==="b")document.getElementById("blackSideBtn").click();
    }else if(gameState==="playing"){
      if(key==="r"&&currentTurn===humanColor&&!diceRolled){
        humanRollDice();
      }else if(key==="m"){
        initPieces();showMenu();
      }
    }else if(["instructions","gameover"].includes(gameState)){
      if(key==="m"){
        initPieces();showMenu();
      }
    }
  });
  canvas.addEventListener("mousedown",handleBoardClick);
  
  function startAll(){
    showMenu();requestAnimationFrame(mainLoop);
  }
  window.addEventListener("load",startAll);
</script>
</body>
</html>
