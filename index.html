<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Royal Game of Ur</title>
  <!-- Dummy favicon -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    body {
      margin: 0; padding: 0;
      background: #fafafa;
      font-family: sans-serif;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    #gameContainer {
      position: relative;
      width: 1020px;
      max-width: 100%;
      padding: 20px;
      box-sizing: border-box;
      background: #fff;
      margin-bottom: 20px;
      border: 2px solid #ccc;
      border-radius: 4px;
    }
    canvas {
      display: block;
      background: #ddd;
      margin: auto;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button,
    #controls input {
      font-size: 16px;
      padding: 6px 10px;
      margin: 4px;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 10;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px; height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- MENU SCREEN -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Another Product Invented<br>Royal Game of Ur</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>How to Play</strong></p>
    <p>
      1) Roll dice or set a custom dice value.<br>
      2) Click one of your pieces (above the board if off-board) to move it.<br>
      3) Landing on a rosette grants an extra turn. You cannot capture an opponent on a rosette.<br>
      4) Exact roll is needed to exit the board (pos=20).
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- SIDE SELECTION SCREEN -->
  <div id="sideScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White (Go First) [W]</button>
    <button id="blackSideBtn">Black (Go Second) [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Canvas for the board (1000×600) -->
  <canvas id="gameCanvas" width="1000" height="600"></canvas>
</div>

<!-- Controls -->
<div id="controls">
  <button id="rollDiceBtn">Roll Dice</button>
  <label for="customDiceInput">Custom Dice:</label>
  <input type="number" id="customDiceInput" min="0" max="4" value="0">
  <button id="setCustomDiceBtn">Set Dice</button>
  <div id="pieceCountDisplay" style="margin-top:8px; font-size:16px;"></div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Thinking...</p>
</div>

<!-- Optional Logo -->
<img id="logo" src="logo.png" alt="Logo">

<script>
/********************************
 * 1) Board Setup & Constants
 *******************************/
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const canvasWidth = canvas.width;   // 1000
const canvasHeight = canvas.height; // 600

// We'll keep squares at 50×50, with the board bounding box ~400×150.
const SQUARE_SIZE = 50;
const boardWidth = 400, boardHeight = 150;
const boardMarginX = (canvasWidth - boardWidth)/2; // e.g. 300
const boardMarginY = (canvasHeight - boardHeight)/2; // e.g. 225

// We'll define 20 squares physically, just like your snippet.
const boardSquares = [
  // Row0
  { x:0,   y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  // col2..3 => gap
  { x:200, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:250, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:350, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },

  // Row1
  { x:0,   y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:100, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:150, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:200, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:250, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:350, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },

  // Row2
  { x:0,   y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  // gap col2..3
  { x:200, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:250, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:350, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  }
];

// White path (0..19 in some order). We'll just do [0,1,2,3,4,5,6..19].
const whitePath = [...Array(20).keys()];
// Black path is reversed
const blackPath = [...whitePath].reverse();

let gameState = "menu"; // "menu","instructions","selectSide","playing","gameover"
let humanColor = null;  // 'w'|'b'
let currentTurn = null; // 'w'|'b'
let currentDiceRoll = 0;
let diceRolled = false;
let extraTurn = false;
let aiThinking = false;
const debugMode = true;

const NUM_PIECES = 7;
let whitePieces = [], blackPieces = [];

// We'll store the last move for highlight
let lastMove = null; // { fromPos, toPos, color }

/********************************
 * 2) Off-board / On-board coords
 *******************************/
// We'll define a helper to get the piece's drawing coords given pos in [-1..20] or 20=finished
// White off-board => row above the top row
// Black off-board => row below the bottom row
// We'll also define a place for finished pieces (pos=20) to the right side.

function getPieceCoords(color, pieceIndex, pos) {
  if(pos>=0 && pos<20) {
    // on the board
    let sq = boardSquares[pos];
    let cx = sq.x + boardMarginX + sq.w/2;
    let cy = sq.y + boardMarginY + sq.h/2;
    return { x: cx, y: cy };
  }
  if(pos===20) {
    // finished => place them on the right side, stacked
    let offsetY = (color==='w')? 100 : 300; 
    // or do something else
    return { x: boardMarginX+boardWidth+ 80, y: boardMarginY + offsetY + pieceIndex*30 };
  }
  if(pos===-1) {
    // off-board => White above row0, Black below row2
    if(color==='w') {
      // place them in a row above the top row
      // let's line them up at y= boardMarginY-60, x= boardMarginX + pieceIndex*(SQUARE_SIZE+5)
      return {
        x: boardMarginX + pieceIndex*(SQUARE_SIZE+5) + 20,
        y: boardMarginY - 60
      };
    } else {
      // black => below row2
      // y= boardMarginY+ boardHeight + 60, x= ...
      return {
        x: boardMarginX + pieceIndex*(SQUARE_SIZE+5) + 20,
        y: boardMarginY + boardHeight + 60
      };
    }
  }
  // fallback
  return { x:0, y:0 };
}

// For highlighting a fromPos=-1 or toPos=20, we'll define a small 40×40 box
function getHighlightBox(color, pieceIndex, pos) {
  let c = getPieceCoords(color, pieceIndex, pos);
  // We'll shift up-left so we can draw a box around the piece
  let x = c.x - 20, y = c.y - 20;
  let w = 40, h = 40;
  return { x, y, w, h };
}

/********************************
 * 3) INIT & UTILS
 *******************************/
function initPieces(){
  whitePieces = Array(NUM_PIECES).fill(-1); // all off-board
  blackPieces = Array(NUM_PIECES).fill(-1);
  lastMove = null;
}
function rollDice(){
  let total=0;
  for(let i=0; i<4; i++){
    total += Math.floor(Math.random()*2);
  }
  return total;
}
function checkForBugs(){
  function checkOverlap(pieces, color){
    const c={};
    pieces.forEach(pos=>{
      if(pos>=0 && pos<20){
        c[pos]=(c[pos]||0)+1;
        if(c[pos]>1){
          console.error(`Overlap bug: ${color} has multiple pieces on #${pos}`);
        }
      }
    });
  }
  checkOverlap(whitePieces,"White");
  checkOverlap(blackPieces,"Black");
}

/********************************
 * 4) PATH LOGIC
 *******************************/
function getPath(color){
  return (color==='w')? whitePath : blackPath;
}

// If piecePos=-1 => pathIndex=-1 => newIndex= -1 + diceValue => if newIndex<0 => invalid, if newIndex= path.length => 20
function getValidMove(piecePos, diceValue, color){
  if(diceValue===0) return null;
  const path = getPath(color);

  // If piece is off-board => treat pathIndex= -1
  let pathIndex = -1;
  if(piecePos>=0 && piecePos<20){
    pathIndex = path.indexOf(piecePos);
    if(pathIndex===-1) {
      if(debugMode) console.warn(`Piece pos ${piecePos} not found in path for color=${color}`);
      return null;
    }
  } else if(piecePos===-1) {
    // do nothing, pathIndex stays -1
  } else if(piecePos===20) {
    // piece is finished => can't move
    return null;
  }
  let newIndex = pathIndex + diceValue;
  if(newIndex> path.length) return null; // overshoot
  if(newIndex===path.length) return 20;  // finished
  return path[newIndex]; // boardSquares index
}

// We also need to check if we can land on that pos (no friendly overlap, no capturing on rosette).
function canLandOn(pos, color){
  const own=(color==='w')? whitePieces: blackPieces;
  const opp=(color==='w')? blackPieces: whitePieces;
  if(pos<20 && own.includes(pos)) return false; // can't land on friendly
  // can't capture on rosette
  if(pos<20 && opp.includes(pos) && boardSquares[pos].rosette){
    return false;
  }
  return true;
}
function getMoveOptions(diceValue, color){
  let result=[];
  const own=(color==='w')? whitePieces: blackPieces;
  own.forEach((pos,i)=>{
    let target = getValidMove(pos,diceValue,color);
    if(target!==null) {
      if(canLandOn(target,color)){
        result.push({ pieceIndex:i, fromPos:pos, toPos: target });
      }
    }
  });
  return result;
}

/********************************
 * 5) MOVES & HIGHLIGHT
 *******************************/
function executeMove(pieceIndex, toPos, color){
  try {
    const own=(color==='w')? whitePieces: blackPieces;
    const opp=(color==='w')? blackPieces: whitePieces;
    let fromPos = own[pieceIndex];
    own[pieceIndex] = toPos;

    // capture
    if(toPos<20){
      let oppIdx=opp.indexOf(toPos);
      if(oppIdx!==-1){
        opp[oppIdx] = -1; // captured => off-board
        if(debugMode) console.log(`${color==='w'?"White":"Black"} captured opponent on #${toPos}`);
      }
    }
    if(debugMode) checkForBugs();

    // store lastMove for highlight
    lastMove = { fromPos, toPos, color: color, pieceIndex };

    // rosette => extra turn
    if(toPos<20 && boardSquares[toPos].rosette){
      extraTurn=true;
    } else {
      extraTurn=false;
    }
    // check finish
    let finishedCount= own.filter(p=>p===20).length;
    if(finishedCount===NUM_PIECES){
      gameState="gameover";
      document.getElementById("gameOverText").textContent=(color===humanColor)?"You Win!":"You Lose!";
    }
    // switch turn if no extra
    if(!extraTurn && gameState==="playing"){
      currentTurn=(currentTurn==='w')?'b':'w';
    }
    diceRolled=false;
    currentDiceRoll=0;
  } catch(err){
    console.error("Error in executeMove:",err);
  }
}

// highlightLastMove now also highlights fromPos if it was -1 or 20, and toPos if it was -1 or 20
function highlightLastMove(){
  if(!lastMove) return;
  let { fromPos, toPos, color, pieceIndex } = lastMove;

  // highlight from
  if(fromPos===-1 || fromPos===20){
    let box = getHighlightBox(color, pieceIndex, fromPos);
    ctx.fillStyle="rgba(255,255,0,0.5)"; // yellow
    ctx.fillRect(box.x, box.y, box.w, box.h);
  } else if(fromPos>=0 && fromPos<20){
    let sq=boardSquares[fromPos];
    let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
    ctx.fillStyle="rgba(255,255,0,0.5)";
    ctx.fillRect(x,y, sq.w,sq.h);
  }
  // highlight to
  if(toPos===-1 || toPos===20){
    let box = getHighlightBox(color, pieceIndex, toPos);
    ctx.fillStyle="rgba(0,128,255,0.5)"; // blue
    ctx.fillRect(box.x, box.y, box.w, box.h);
  } else if(toPos>=0 && toPos<20){
    let sq=boardSquares[toPos];
    let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
    ctx.fillStyle="rgba(0,128,255,0.5)";
    ctx.fillRect(x,y, sq.w,sq.h);
  }
}

/********************************
 * 6) DRAWING & INPUT
 *******************************/
function getPieceDrawCoords(color, pieceIndex, pos){
  // return the center coords for drawing
  let { x, y } = getPieceCoords(color, pieceIndex, pos);
  return { cx: x, cy: y };
}

function drawBoard(){
  ctx.clearRect(0,0, canvasWidth, canvasHeight);
  highlightLastMove();

  // squares
  boardSquares.forEach((sq,i)=>{
    let drawX = sq.x+boardMarginX, drawY = sq.y+boardMarginY;
    let grad=ctx.createLinearGradient(drawX,drawY, drawX+sq.w,drawY+sq.h);
    grad.addColorStop(0,"#e6c87d");
    grad.addColorStop(1,"#4e6fa3");
    ctx.fillStyle=grad;
    ctx.fillRect(drawX,drawY,sq.w,sq.h);
    ctx.strokeStyle="#000"; ctx.lineWidth=2;
    ctx.strokeRect(drawX,drawY,sq.w,sq.h);

    if(sq.rosette){
      ctx.save();
      ctx.translate(drawX+sq.w/2, drawY+sq.h/2);
      ctx.beginPath();
      ctx.arc(0,0,10,0,Math.PI*2);
      ctx.fillStyle="red"; ctx.fill();
      ctx.strokeStyle="#fff"; ctx.lineWidth=2;
      ctx.beginPath();
      for(let arm=0; arm<8; arm++){
        ctx.moveTo(0,0);
        let angle=(Math.PI*2)*(arm/8);
        ctx.lineTo(Math.cos(angle)*10, Math.sin(angle)*10);
      }
      ctx.stroke();
      ctx.restore();
    }
  });
}

function drawPieces(){
  // White
  whitePieces.forEach((pos, i)=>{
    if(pos===20) {
      // finished => draw on the right
    }
    let { x, y } = getPieceCoords('w', i, pos);
    // draw piece center x,y
    ctx.save();
    ctx.shadowColor="rgba(0,0,0,0.4)";
    ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
    let grad=ctx.createRadialGradient(x-5,y-5,5,x,y,18);
    grad.addColorStop(0,"#ffffff");
    grad.addColorStop(1,"#d0d0d0");
    ctx.beginPath();
    ctx.arc(x,y,18,0,Math.PI*2);
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle="#000"; ctx.lineWidth=2;
    ctx.stroke();
    ctx.restore();
  });
  // Black
  blackPieces.forEach((pos, i)=>{
    let { x, y } = getPieceCoords('b', i, pos);
    ctx.save();
    ctx.shadowColor="rgba(0,0,0,0.5)";
    ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
    let grad=ctx.createRadialGradient(x-5,y-5,5,x,y,18);
    grad.addColorStop(0,"#666666");
    grad.addColorStop(1,"#000000");
    ctx.beginPath();
    ctx.arc(x,y,18,0,Math.PI*2);
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle="#fff"; ctx.lineWidth=2;
    ctx.stroke();
    ctx.restore();
  });
}

function drawUI(){
  ctx.fillStyle="#fff";
  ctx.fillRect(0, canvasHeight-30, canvasWidth, 30);
  ctx.fillStyle="#000";
  ctx.font="16px sans-serif";
  let txt = `Turn: ${currentTurn==="w"?"White":"Black"}. `;
  if(currentTurn===humanColor && !diceRolled){
    txt += "Click 'Roll Dice' or press [R]. ";
  } else if(diceRolled){
    txt += `Dice: ${currentDiceRoll}. `;
  }
  const whiteOff=whitePieces.filter(p=>p===-1).length;
  const blackOff=blackPieces.filter(p=>p===-1).length;
  txt += `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
  ctx.fillText(txt, 10, canvasHeight-10);
}

function redrawPlayScreen(){
  drawBoard();
  drawPieces();
  drawUI();
}

function handleBoardClick(e){
  if(gameState!=="playing") return;
  if(currentTurn!==humanColor) return; // must be player's turn
  if(!diceRolled){
    if(debugMode) console.warn("Must roll dice before moving a piece!");
    return;
  }
  // get moves
  let moves = getMoveOptions(currentDiceRoll, currentTurn);
  if(moves.length===0){
    if(debugMode) console.warn("No valid moves => pass turn!");
  }
  // check if clicked on a piece
  let rect=canvas.getBoundingClientRect();
  let mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const own=(currentTurn==='w')? whitePieces : blackPieces;

  for(let i=0; i<own.length; i++){
    let pos=own[i];
    if(pos===20) continue; // finished
    let found = moves.find(m=>m.pieceIndex===i);
    // get piece center
    let { x, y } = getPieceCoords(currentTurn, i, pos);
    let dx=mx-x, dy=my-y;
    if(Math.sqrt(dx*dx+dy*dy)<=18){
      if(!found){
        if(debugMode) console.warn(`Piece #${i} has no valid move (dice=${currentDiceRoll}).`);
        return;
      }
      // do the move
      executeMove(i, found.toPos, currentTurn);
      redrawPlayScreen();
      return;
    }
  }
}

/********************************
 * 7) ROLL DICE & AI
 *******************************/
function humanRollDice(){
  if(gameState!=="playing") return;
  if(currentTurn!==humanColor) return;
  if(diceRolled){
    if(debugMode) console.warn("Bug: Already rolled dice this turn!");
    return;
  }
  currentDiceRoll=rollDice();
  diceRolled=true;
  if(debugMode) console.log(`Human rolled: ${currentDiceRoll}`);
  let options = getMoveOptions(currentDiceRoll, currentTurn);
  if(options.length===0){
    if(debugMode) console.warn("No valid moves => pass turn to opponent.");
    diceRolled=false;
    currentDiceRoll=0;
    currentTurn=(currentTurn==='w')?'b':'w';
  }
  redrawPlayScreen();
}

function aiMove(){
  if(gameState!=="playing") return;
  if(currentTurn===humanColor) return;
  aiThinking=true;
  document.getElementById("loadingOverlay").style.display="flex";

  setTimeout(()=>{
    currentDiceRoll=rollDice();
    diceRolled=true;
    if(debugMode) console.log(`AI (${currentTurn==='w'?'White':'Black'}) rolled: ${currentDiceRoll}`);
    let options = getMoveOptions(currentDiceRoll, currentTurn);
    if(options.length>0){
      let pick = options[Math.floor(Math.random()*options.length)];
      executeMove(pick.pieceIndex, pick.toPos, currentTurn);
    } else {
      if(debugMode) console.warn("AI has no valid moves => pass turn!");
      diceRolled=false;
      currentDiceRoll=0;
      currentTurn=(currentTurn==='w')?'b':'w';
    }
    aiThinking=false;
    document.getElementById("loadingOverlay").style.display="none";
    redrawPlayScreen();
  },1500);
}

/********************************
 * 8) MAIN LOOP
 *******************************/
function mainLoop(){
  if(gameState==="playing"){
    redrawPlayScreen();
    // show/hide roll dice
    if(currentTurn===humanColor && !diceRolled){
      document.getElementById("rollDiceBtn").style.display="inline-block";
    } else {
      document.getElementById("rollDiceBtn").style.display="none";
    }
    // AI turn?
    if(currentTurn!==humanColor && !diceRolled && !aiThinking){
      aiMove();
    }
    // piece counts
    const whiteOff=whitePieces.filter(p=>p===-1).length;
    const blackOff=blackPieces.filter(p=>p===-1).length;
    document.getElementById("pieceCountDisplay").textContent=
      `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
  }
  requestAnimationFrame(mainLoop);
}

/********************************
 * 9) OVERLAYS & MENU
 *******************************/
function hideAllScreens(){
  document.getElementById("menuScreen").style.display="none";
  document.getElementById("instructionsScreen").style.display="none";
  document.getElementById("sideScreen").style.display="none";
  document.getElementById("gameOverScreen").style.display="none";
}
function showMenu(){
  hideAllScreens();
  gameState="menu";
  document.getElementById("menuScreen").style.display="flex";
}
function showInstructions(){
  hideAllScreens();
  gameState="instructions";
  document.getElementById("instructionsScreen").style.display="flex";
}
function showSideSelect(){
  hideAllScreens();
  gameState="selectSide";
  document.getElementById("sideScreen").style.display="flex";
}
function startPlaying(){
  hideAllScreens();
  gameState="playing";
  initPieces();
  currentTurn="w"; // White starts
  diceRolled=false; currentDiceRoll=0; extraTurn=false;
}
function showGameOver(){
  hideAllScreens();
  gameState="gameover";
  document.getElementById("gameOverScreen").style.display="flex";
}

/********************************
 * 10) BUTTONS & KEYS
 *******************************/
document.getElementById("newGameBtn").onclick=()=>showSideSelect();
document.getElementById("instructionsBtn").onclick=()=>showInstructions();
document.getElementById("whiteSideBtn").onclick=()=>{
  humanColor='w'; startPlaying();
};
document.getElementById("blackSideBtn").onclick=()=>{
  humanColor='b'; startPlaying();
};
document.getElementById("gameOverNewGameBtn").onclick=()=>showSideSelect();
document.getElementById("rollDiceBtn").addEventListener("click", humanRollDice);

// custom dice
document.getElementById("setCustomDiceBtn").addEventListener("click",()=>{
  const val=parseInt(document.getElementById("customDiceInput").value,10);
  if(!isNaN(val) && val>=0 && val<=4){
    currentDiceRoll=val;
    diceRolled=true;
    if(debugMode) console.log(`Custom dice set to: ${currentDiceRoll}`);
    redrawPlayScreen();
  }
});

document.addEventListener("keydown",(e)=>{
  const key=e.key.toLowerCase();
  if(gameState==="selectSide"){
    if(key==="w") document.getElementById("whiteSideBtn").click();
    else if(key==="b") document.getElementById("blackSideBtn").click();
  } else if(gameState==="playing"){
    if(key==="r" && currentTurn===humanColor && !diceRolled){
      humanRollDice();
    } else if(key==="m"){
      initPieces(); showMenu();
    }
  } else if(["instructions","gameover"].includes(gameState)){
    if(key==="m"){
      initPieces(); showMenu();
    }
  }
});

canvas.addEventListener("mousedown", handleBoardClick);

function startAll(){
  showMenu();
  requestAnimationFrame(mainLoop);
}
window.addEventListener("load", startAll);
</script>
</body>
</html>
