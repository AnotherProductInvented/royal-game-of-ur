<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Royal Game of Ur</title>
  <!-- Dummy favicon so no 404 error -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    body {
      margin: 0; padding: 0;
      background: #fafafa;
      font-family: sans-serif;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    #gameContainer {
      position: relative;
      width: 1020px;
      max-width: 100%;
      padding: 20px;
      box-sizing: border-box;
      background: #fff;
      margin-bottom: 20px;
      border: 2px solid #ccc;
      border-radius: 4px;
    }
    canvas {
      display: block;
      background: #ddd;
      margin: auto;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button,
    #controls input {
      font-size: 16px;
      padding: 6px 10px;
      margin: 4px;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 10;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- MENU SCREEN -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Another Product Invented<br>Royal Game of Ur</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>How to Play</strong></p>
    <p>
      1) Roll dice or set a custom dice value.<br>
      2) Click one of your pieces to move it.<br>
      3) Landing on a rosette grants an extra turn.<br>
      4) You cannot capture on a rosette.<br>
      5) Need an exact roll to exit (square #20).
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- SIDE SELECTION SCREEN -->
  <div id="sideScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White (Go First) [W]</button>
    <button id="blackSideBtn">Black (Go Second) [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Canvas for the board (1000×600) -->
  <canvas id="gameCanvas" width="1000" height="600"></canvas>
</div>

<!-- Controls -->
<div id="controls">
  <button id="rollDiceBtn">Roll Dice</button>
  <label for="customDiceInput">Custom Dice:</label>
  <input type="number" id="customDiceInput" min="0" max="4" value="0">
  <button id="setCustomDiceBtn">Set Dice</button>
  <div id="pieceCountDisplay" style="margin-top:8px; font-size:16px;"></div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Thinking...</p>
</div>

<!-- Optional Logo -->
<img id="logo" src="logo.png" alt="Logo">

<script>
  /*************************************
   * 1) GLOBALS & BOARD LAYOUT
   *************************************/
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");
  const canvasWidth = canvas.width;   // 1000
  const canvasHeight = canvas.height; // 600
  const SQUARE_SIZE = 50;

  // We'll define a 3×8 arrangement with some squares labeled "gap."
  // Then we define the White path in the order your snippet suggests:
  //  top row: squares labeled 13,14, gap, gap, then 1,2,3,4
  //  middle row: 12..5
  //  bottom row: 1,1, gap, gap, 1,1,1,1? (Your snippet had repeated "1"? We'll just treat them as squares.)
  //  But we only have 20 squares total (0..19).
  // We store them physically in an array with x,y coords, plus rosettes as needed.

  // We'll place them in a 3 row bounding box: 400 wide × 150 tall => center in 1000×600.
  // boardMarginX, boardMarginY to center
  const boardWidth = 400, boardHeight = 150;
  const boardMarginX = (canvasWidth - boardWidth)/2; // e.g. (1000-400)/2=300
  const boardMarginY = (canvasHeight - boardHeight)/2; // e.g. (600-150)/2=225

  // We'll define squares 0..19 with your labeling approach:
  //   Row0: col0 => "13", col1 => "14", col2=>gap, col3=>gap, col4=>"1", col5=>"2", col6=>"3", col7=>"4"
  //   Row1: col0=>"12", col1=>"11", col2=>"10", col3=>"9", col4=>"8", col5=>"7", col6=>"6", col7=>"5"
  //   Row2: col0=>"1", col1=>"1", col2=>gap, col3=>gap, col4=>"1", col5=>"1", col6=>"1", col7=>"1"
  //
  // But physically we only have 20 squares. We'll define them in an array with some labeled rosettes if needed.
  // For simplicity, let's assume rosettes are on squares #4, #8, #13, #14, #19 (like a standard pattern).
  // Adjust as needed.

  const boardSquares = [
    // Row0 (y=0) => top row
    // index0 => "13"
    { x: 0,   y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #0 => "13"
    // index1 => "14"
    { x: 50,  y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #1 => "14"
    // col2 => gap
    // col3 => gap
    // index2 => "1"
    { x: 200, y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #2 => "1"
    // index3 => "2"
    { x: 250, y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #3 => "2"
    // index4 => "3"
    { x: 300, y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // #4 => "3" (rosette?)
    // index5 => "4"
    { x: 350, y: 0, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #5 => "4"

    // Row1 (y=50) => middle row => 12..5
    { x: 0,   y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #6 => "12"
    { x: 50,  y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // #7 => "11" (rosette?)
    { x: 100, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #8 => "10"
    { x: 150, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #9 => "9"
    { x: 200, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }, // #10 => "8" (rosette?)
    { x: 250, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #11 => "7"
    { x: 300, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #12 => "6"
    { x: 350, y: 50, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #13 => "5"

    // Row2 (y=100) => bottom row => 1,1 gap gap 1,1,1,1
    { x: 0,   y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #14 => "1"
    { x: 50,  y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #15 => "1"
    // col2 => gap
    // col3 => gap
    { x: 200, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #16 => "1"
    { x: 250, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #17 => "1"
    { x: 300, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: false }, // #18 => "1"
    { x: 350, y: 100, w: SQUARE_SIZE, h: SQUARE_SIZE, rosette: true  }  // #19 => "1" (rosette?)
  ];

  // Next, define the White path in your snippet order:
  //   top row => squares #0=>13, #1=>14, then #2=>1, #3=>2, #4=>3, #5=>4
  //   middle row => #6=>12, #7=>11, #8=>10, #9=>9, #10=>8, #11=>7, #12=>6, #13=>5
  //   bottom row => #14..#19 => all "1" squares
  const whitePath = [0,1,2,3,4,5, 6,7,8,9,10,11,12,13, 14,15,16,17,18,19];

  // For Black, do the same in reverse order:
  //   We'll just define blackPath as reversed(whitePath).
  const blackPath = [...whitePath].reverse();

  /****************************************
   * GAME STATE ARRAYS & PATHS
   ****************************************/
  let gameState = "menu";  // "menu", "instructions", "selectSide", "playing", "gameover"
  let humanColor = null;   // 'w' or 'b'
  let currentTurn = null;  // 'w' or 'b'
  let currentDiceRoll = 0;
  let diceRolled = false;
  let extraTurn = false;
  let aiThinking = false;
  const debugMode = true;

  // White & Black pieces: positions in [-1..20], where -1=off-board, 20=finished.
  const NUM_PIECES = 7;
  let whitePieces = [];
  let blackPieces = [];

  // Store last move for highlight
  let lastMove = null; // { fromPos, toPos, color }

  function initPieces() {
    whitePieces = Array(NUM_PIECES).fill(-1);
    blackPieces = Array(NUM_PIECES).fill(-1);
    lastMove = null;
  }

  /****************************************
   * UTILITY & DEBUG
   ****************************************/
  function rollDice() {
    let total = 0;
    for (let i=0; i<4; i++){
      total += Math.floor(Math.random() * 2);
    }
    return total;
  }
  function checkForBugs() {
    function checkOverlap(pieces, color) {
      const counts = {};
      pieces.forEach(pos=>{
        if(pos>=0 && pos<20){
          counts[pos]=(counts[pos]||0)+1;
          if(counts[pos]>1){
            console.error(`Bug: Overlap => ${color} has multiple pieces on #${pos}`);
          }
        }
      });
    }
    checkOverlap(whitePieces,"White");
    checkOverlap(blackPieces,"Black");
  }

  /****************************************
   * PATH HELPERS
   ****************************************/
  // getPath('w') => whitePath, getPath('b') => blackPath
  function getPath(color) {
    return (color==='w')? whitePath : blackPath;
  }

  /****************************************
   * DRAWING
   ****************************************/
  function highlightLastMove(){
    if(!lastMove) return;
    const { fromPos, toPos, color } = lastMove;
    // We have fromPos and toPos as path indices, not direct boardSquares indices if we’re using a path.
    // Actually, in this snippet we’ll store fromPos as a direct boardSquares index. So we can highlight that square.
    if(fromPos>=0 && fromPos<20){
      let sq=boardSquares[fromPos];
      let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
      ctx.fillStyle="rgba(255,255,0,0.5)"; // yellow
      ctx.fillRect(x,y, sq.w,sq.h);
    }
    if(toPos>=0 && toPos<20){
      let sq=boardSquares[toPos];
      let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
      ctx.fillStyle="rgba(0,128,255,0.5)"; // blue
      ctx.fillRect(x,y, sq.w,sq.h);
    }
  }

  function drawBoard() {
    ctx.clearRect(0,0,canvasWidth,canvasHeight);
    // highlight last move squares first
    highlightLastMove();

    // Draw squares
    boardSquares.forEach((sq,i)=>{
      if(!isFinite(sq.w)) sq.w=SQUARE_SIZE;
      if(!isFinite(sq.h)) sq.h=SQUARE_SIZE;
      let drawX = sq.x+boardMarginX;
      let drawY = sq.y+boardMarginY;
      let grad = ctx.createLinearGradient(drawX,drawY, drawX+sq.w, drawY+sq.h);
      grad.addColorStop(0,"#e6c87d");
      grad.addColorStop(1,"#4e6fa3");
      ctx.fillStyle=grad;
      ctx.fillRect(drawX,drawY,sq.w,sq.h);
      ctx.strokeStyle="#000";
      ctx.lineWidth=2;
      ctx.strokeRect(drawX,drawY,sq.w,sq.h);

      if(sq.rosette){
        ctx.save();
        ctx.translate(drawX+sq.w/2, drawY+sq.h/2);
        ctx.beginPath();
        ctx.arc(0,0,10,0,Math.PI*2);
        ctx.fillStyle="red";
        ctx.fill();
        ctx.strokeStyle="#fff";
        ctx.lineWidth=2;
        ctx.beginPath();
        for(let arm=0; arm<8; arm++){
          ctx.moveTo(0,0);
          let angle=(Math.PI*2)*(arm/8);
          ctx.lineTo(Math.cos(angle)*10, Math.sin(angle)*10);
        }
        ctx.stroke();
        ctx.restore();
      }
    });
  }

  function drawPieces(){
    // White
    whitePieces.forEach(pos=>{
      if(pos<0||pos>=20) return;
      let sq=boardSquares[pos];
      let cx=sq.x+boardMarginX+sq.w/2;
      let cy=sq.y+boardMarginY+sq.h/2;
      ctx.save();
      ctx.shadowColor="rgba(0,0,0,0.4)";
      ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
      let grad=ctx.createRadialGradient(cx-5,cy-5,5,cx,cy,18);
      grad.addColorStop(0,"#ffffff");
      grad.addColorStop(1,"#d0d0d0");
      ctx.beginPath();
      ctx.arc(cx,cy,18,0,Math.PI*2);
      ctx.fillStyle=grad; ctx.fill();
      ctx.strokeStyle="#000"; ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    });
    // Black
    blackPieces.forEach(pos=>{
      if(pos<0||pos>=20) return;
      let sq=boardSquares[pos];
      let cx=sq.x+boardMarginX+sq.w/2;
      let cy=sq.y+boardMarginY+sq.h/2;
      ctx.save();
      ctx.shadowColor="rgba(0,0,0,0.5)";
      ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
      let grad=ctx.createRadialGradient(cx-5,cy-5,5,cx,cy,18);
      grad.addColorStop(0,"#666666");
      grad.addColorStop(1,"#000000");
      ctx.beginPath();
      ctx.arc(cx,cy,18,0,Math.PI*2);
      ctx.fillStyle=grad; ctx.fill();
      ctx.strokeStyle="#fff"; ctx.lineWidth=2;
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawUI(){
    ctx.fillStyle="#fff";
    ctx.fillRect(0, canvasHeight-30, canvasWidth, 30);
    ctx.fillStyle="#000";
    ctx.font="16px sans-serif";
    let txt = `Turn: ${currentTurn==="w"?"White":"Black"}. `;
    if(currentTurn===humanColor && !diceRolled){
      txt += "Click 'Roll Dice' or press [R]. ";
    } else if(diceRolled){
      txt += `Dice: ${currentDiceRoll}. `;
    }
    const whiteOff=whitePieces.filter(p=>p===-1).length;
    const blackOff=blackPieces.filter(p=>p===-1).length;
    txt += `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
    ctx.fillText(txt, 10, canvasHeight-10);
  }

  function redrawPlayScreen(){
    drawBoard();
    drawPieces();
    drawUI();
  }

  /****************************************
   * GAME LOGIC
   ****************************************/
  function getValidMove(piecePos, diceValue, color) {
    if(diceValue===0) return null;
    const path = getPath(color);
    // piecePos is the index in boardSquares
    // find where that index is in the path
    let pathIndex = path.indexOf(piecePos);
    if(pathIndex===-1){
      if(debugMode) console.warn(`Bug: piecePos ${piecePos} not found in path for color=${color}`);
      return null;
    }
    let newIndex = pathIndex + diceValue;
    if(newIndex>path.length) return null; // overshoot
    // if exactly path.length => piece finishes
    if(newIndex===path.length) return 20; // finished
    // else newIndex < path.length => new boardSquares index
    return path[newIndex];
  }

  function canLandOn(pos, color) {
    // check if can't land on friendly piece
    const own = (color==='w')? whitePieces : blackPieces;
    const opp = (color==='w')? blackPieces : whitePieces;
    if(pos<20 && own.includes(pos)) return false; // can't land
    // can't capture on rosette
    if(pos<20 && opp.includes(pos) && boardSquares[pos].rosette){
      return false;
    }
    return true;
  }

  function getMoveOptions(diceValue, color) {
    let result = [];
    const own = (color==='w')? whitePieces : blackPieces;
    own.forEach((sqIndex, i)=>{
      if(sqIndex===20) return; // piece is finished
      let target = getValidMove(sqIndex, diceValue, color);
      if(target!==null) {
        // check if we can land
        if(target<21 && canLandOn(target,color)){
          result.push({ pieceIndex:i, fromPos: sqIndex, toPos: target });
        }
      }
    });
    return result;
  }

  function executeMove(pieceIndex, toPos, color) {
    try {
      const own = (color==='w')? whitePieces : blackPieces;
      const opp = (color==='w')? blackPieces : whitePieces;
      let fromPos = own[pieceIndex];
      own[pieceIndex] = toPos;

      // capture
      if(toPos<20){
        let oppIdx = opp.indexOf(toPos);
        if(oppIdx!==-1){
          opp[oppIdx] = -1; // captured => off-board
          if(debugMode) console.log(`${color==='w'?"White":"Black"} captured opponent on #${toPos}`);
        }
      }
      if(debugMode) checkForBugs();

      // highlight
      lastMove = { fromPos, toPos, color };

      // rosette => extra turn
      if(toPos<20 && boardSquares[toPos].rosette){
        extraTurn=true;
      } else {
        extraTurn=false;
      }
      // check if finished all
      let finishedCount = own.filter(p=>p===20).length;
      if(finishedCount===NUM_PIECES){
        gameState="gameover";
        document.getElementById("gameOverText").textContent=(color===humanColor)?"You Win!":"You Lose!";
      }
      // switch turn if no extra
      if(!extraTurn && gameState==="playing"){
        currentTurn=(currentTurn==='w')?'b':'w';
      }
      diceRolled=false;
      currentDiceRoll=0;
    } catch(err) {
      console.error("Error in executeMove:", err);
    }
  }

  function handleBoardClick(e) {
    if(gameState!=="playing") return;
    if(currentTurn!==humanColor) return; // must be player's turn
    if(!diceRolled) {
      if(debugMode) console.warn("Bug: You must roll dice before moving.");
      return;
    }

    const own = (currentTurn==='w')? whitePieces : blackPieces;
    let rect=canvas.getBoundingClientRect();
    let mx=e.clientX-rect.left, my=e.clientY-rect.top;

    // get possible moves
    let moves = getMoveOptions(currentDiceRoll, currentTurn);
    if(moves.length===0 && debugMode){
      console.warn("No valid moves for you right now. Passing turn!");
    }

    for(let i=0; i<own.length; i++){
      let pos=own[i];
      if(pos<0||pos>=20) continue; // off-board or finished
      // check if user clicked on this piece
      let sq=boardSquares[pos];
      let cx=sq.x+boardMarginX+sq.w/2;
      let cy=sq.y+boardMarginY+sq.h/2;
      let dx=mx-cx, dy=my-cy;
      if(Math.sqrt(dx*dx + dy*dy)<=18){
        // see if there's a move for it
        let found = moves.find(m=>m.pieceIndex===i);
        if(!found){
          if(debugMode) console.warn(`Piece #${i} has no valid move with dice=${currentDiceRoll}`);
          return;
        }
        // do the move
        executeMove(i, found.toPos, currentTurn);
        redrawPlayScreen();
        return;
      }
    }
  }

  function humanRollDice(){
    if(gameState!=="playing") return;
    if(currentTurn!==humanColor) return;
    if(diceRolled) {
      if(debugMode) console.warn("Bug: Already rolled dice, can't roll again now.");
      return;
    }
    currentDiceRoll=rollDice();
    diceRolled=true;
    if(debugMode) console.log(`Human rolled: ${currentDiceRoll}`);
    let moves = getMoveOptions(currentDiceRoll, currentTurn);
    if(moves.length===0){
      if(debugMode) console.warn("No valid moves => pass turn to opponent.");
      diceRolled=false;
      currentDiceRoll=0;
      currentTurn=(currentTurn==='w')?'b':'w';
    }
    redrawPlayScreen();
  }

  function aiMove() {
    if(gameState!=="playing") return;
    if(currentTurn===humanColor) return;
    aiThinking=true;
    document.getElementById("loadingOverlay").style.display="flex";
    setTimeout(()=>{
      currentDiceRoll=rollDice();
      diceRolled=true;
      if(debugMode) console.log(`AI (${currentTurn==='w'?'White':'Black'}) rolled: ${currentDiceRoll}`);
      let moves = getMoveOptions(currentDiceRoll, currentTurn);
      if(moves.length>0){
        let pick = moves[Math.floor(Math.random()*moves.length)];
        executeMove(pick.pieceIndex, pick.toPos, currentTurn);
      } else {
        if(debugMode) console.warn("AI has no valid moves => pass turn.");
        diceRolled=false;
        currentDiceRoll=0;
        currentTurn=(currentTurn==='w')?'b':'w';
      }
      aiThinking=false;
      document.getElementById("loadingOverlay").style.display="none";
      redrawPlayScreen();
    },1500);
  }

  function mainLoop(){
    if(gameState==="playing"){
      redrawPlayScreen();
      // show/hide roll dice
      if(currentTurn===humanColor && !diceRolled){
        document.getElementById("rollDiceBtn").style.display="inline-block";
      } else {
        document.getElementById("rollDiceBtn").style.display="none";
      }
      // AI turn if needed
      if(currentTurn!==humanColor && !diceRolled && !aiThinking){
        aiMove();
      }
      // piece count
      const whiteOff=whitePieces.filter(p=>p===-1).length;
      const blackOff=blackPieces.filter(p=>p===-1).length;
      document.getElementById("pieceCountDisplay").textContent=
        `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
    }
    requestAnimationFrame(mainLoop);
  }

  /****************************************
   * OVERLAY & MENU
   ****************************************/
  function hideAllScreens(){
    document.getElementById("menuScreen").style.display="none";
    document.getElementById("instructionsScreen").style.display="none";
    document.getElementById("sideScreen").style.display="none";
    document.getElementById("gameOverScreen").style.display="none";
  }
  function showMenu(){
    hideAllScreens(); gameState="menu";
    document.getElementById("menuScreen").style.display="flex";
  }
  function showInstructions(){
    hideAllScreens(); gameState="instructions";
    document.getElementById("instructionsScreen").style.display="flex";
  }
  function showSideSelect(){
    hideAllScreens(); gameState="selectSide";
    document.getElementById("sideScreen").style.display="flex";
  }
  function startPlaying(){
    hideAllScreens(); gameState="playing";
    initPieces();
    currentTurn="w"; // White starts
    diceRolled=false; currentDiceRoll=0; extraTurn=false;
  }
  function showGameOver(){
    hideAllScreens(); gameState="gameover";
    document.getElementById("gameOverScreen").style.display="flex";
  }

  // Buttons
  document.getElementById("newGameBtn").onclick=()=>showSideSelect();
  document.getElementById("instructionsBtn").onclick=()=>showInstructions();
  document.getElementById("whiteSideBtn").onclick=()=>{
    humanColor='w';
    startPlaying();
  };
  document.getElementById("blackSideBtn").onclick=()=>{
    humanColor='b';
    startPlaying();
  };
  document.getElementById("gameOverNewGameBtn").onclick=()=>showSideSelect();
  document.getElementById("rollDiceBtn").addEventListener("click", humanRollDice);

  // Custom dice
  document.getElementById("setCustomDiceBtn").addEventListener("click",()=>{
    const val = parseInt(document.getElementById("customDiceInput").value,10);
    if(!isNaN(val) && val>=0 && val<=4){
      currentDiceRoll=val;
      diceRolled=true;
      if(debugMode) console.log(`Custom dice set to: ${currentDiceRoll}`);
      redrawPlayScreen();
    }
  });

  // Keyboard shortcuts
  document.addEventListener("keydown",(e)=>{
    const key=e.key.toLowerCase();
    if(gameState==="selectSide"){
      if(key==="w") document.getElementById("whiteSideBtn").click();
      else if(key==="b") document.getElementById("blackSideBtn").click();
    } else if(gameState==="playing"){
      if(key==="r" && currentTurn===humanColor && !diceRolled){
        humanRollDice();
      } else if(key==="m"){
        initPieces();
        showMenu();
      }
    } else if(["instructions","gameover"].includes(gameState)){
      if(key==="m"){
        initPieces();
        showMenu();
      }
    }
  });

  canvas.addEventListener("mousedown", handleBoardClick);

  function startAll(){
    showMenu();
    requestAnimationFrame(mainLoop);
  }
  window.addEventListener("load", startAll);
</script>
</body>
</html>
