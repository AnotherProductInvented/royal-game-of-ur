<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Royal Game of Ur</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #fafafa;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
    }
    #gameContainer {
      position: relative;
      width: 640px;
      max-width: 100%;
    }
    canvas {
      display: block;
      background: #ddd;
      /* Size chosen to fit 3 rows × 8 columns with some gaps. */
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 10;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
    }
    /* Roll Dice button appears during human turn if dice not rolled yet */
    #rollDiceBtn {
      display: none;
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
    }
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Logo in bottom-right corner */
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- MENU SCREEN -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Another Product Invented<br>Royal Game of Ur</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>How to Play</strong></p>
    <p>This board is laid out with 3 rows × 8 columns, but some cells are “gaps.” Only 20 squares exist, 5 of which are rosettes (special squares). On your turn, roll four binary dice (values 0–4) and move one piece forward that many squares, if valid. Rosettes grant an extra turn, and capturing is not allowed on rosettes.</p>
    <p>Exact rolls are needed to leave the board (past square #19). The first player to move all 7 pieces off the board wins!</p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- SIDE SELECTION SCREEN -->
  <div id="sideScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White (Go First) [W]</button>
    <button id="blackSideBtn">Black (Go Second) [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- Canvas for the T-shaped board (3 rows × 8 columns, with gaps) -->
  <!-- We'll do 8 columns × 80px each = 640 width, and 3 rows × 80px = 240 height. -->
  <canvas id="gameCanvas" width="640" height="240"></canvas>

  <!-- Roll Dice Button -->
  <button id="rollDiceBtn">Roll Dice</button>
</div>

<!-- Loading/Thinking Overlay with Spinner (for AI moves) -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Thinking...</p>
</div>

<!-- Logo (optional) -->
<img id="logo" src="logo.png" alt="Logo">

<script>
  /***** Board Layout Based on Your Snippet *****
    Rows: 3 (row=0..2), Cols: 8 (col=0..7)
    "0" => gap, no square
    "1" => normal square
    "rosette" => special square
    Top row snippet:    1, rosette, 0, 0, 1, 1, 1, rosette
    Middle row snippet: 1, 1, 1, 1, rosette, 1, 1, 1
    Bottom row snippet: 1, rosette, 0, 0, 1, 1, 1, rosette
    => total 20 squares. We'll list them left-to-right, top-to-bottom, skipping gaps.
  *****/

  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  // Overlays & UI
  const menuScreen = document.getElementById("menuScreen");
  const instructionsScreen = document.getElementById("instructionsScreen");
  const sideScreen = document.getElementById("sideScreen");
  const gameOverScreen = document.getElementById("gameOverScreen");
  const gameOverText = document.getElementById("gameOverText");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const rollDiceBtn = document.getElementById("rollDiceBtn");

  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;
  const SQUARE_SIZE = 80; // each cell is 80×80

  // We'll define the 20 squares in reading order:
  // (row=0, col=0 => index 0),
  // (row=0, col=1 => index 1 [rosette]),
  // skip col=2..3 => gap
  // (row=0, col=4 => index 2),
  // (row=0, col=5 => index 3),
  // (row=0, col=6 => index 4),
  // (row=0, col=7 => index 5 [rosette]),
  // row=1, col=0..7 => indices 6..13 (with col=4 => rosette),
  // row=2, col=0 => index 14,
  // row=2, col=1 => index 15 [rosette],
  // skip col=2..3 => gap
  // row=2, col=4 => index 16,
  // row=2, col=5 => index 17,
  // row=2, col=6 => index 18,
  // row=2, col=7 => index 19 [rosette]

  const boardSquares = [
    // Row 0
    { x:0,   y:0,   rosette:false }, // index 0
    { x:80,  y:0,   rosette:true  }, // index 1
    { x:320, y:0,   rosette:false }, // index 2
    { x:400, y:0,   rosette:false }, // index 3
    { x:480, y:0,   rosette:false }, // index 4
    { x:560, y:0,   rosette:true  }, // index 5

    // Row 1 (8 squares in a row)
    { x:0,   y:80,  rosette:false }, // index 6
    { x:80,  y:80,  rosette:false }, // 7
    { x:160, y:80,  rosette:false }, // 8
    { x:240, y:80,  rosette:false }, // 9
    { x:320, y:80,  rosette:true  }, // 10
    { x:400, y:80,  rosette:false }, // 11
    { x:480, y:80,  rosette:false }, // 12
    { x:560, y:80,  rosette:false }, // 13

    // Row 2
    { x:0,   y:160, rosette:false }, // 14
    { x:80,  y:160, rosette:true  }, // 15
    { x:320, y:160, rosette:false }, // 16
    { x:400, y:160, rosette:false }, // 17
    { x:480, y:160, rosette:false }, // 18
    { x:560, y:160, rosette:true  }, // 19
  ];

  // Game state
  let gameState = "menu"; // "menu", "instructions", "selectSide", "playing", "gameover"
  let humanColor = null;  // "w" or "b"
  let currentTurn = null; // "w" or "b" — White always starts
  let currentDiceRoll = 0;
  let diceRolled = false;
  let extraTurn = false;
  let aiThinking = false;
  const debugMode = true;

  // 7 pieces for each side
  // positions in [–1..20], –1 => off-board, 20 => finished
  let whitePieces = [];
  let blackPieces = [];

  const NUM_PIECES = 7;

  function initPieces() {
    whitePieces = Array(NUM_PIECES).fill(-1);
    blackPieces = Array(NUM_PIECES).fill(-1);
  }

  /***** Utility & Debug *****/
  function rollDice() {
    let total = 0;
    for (let i = 0; i < 4; i++){
      total += Math.floor(Math.random() * 2);
    }
    return total;
  }
  function checkForBugs() {
    function checkOverlap(pieces, color) {
      const counts = {};
      pieces.forEach(pos => {
        if (pos >= 0 && pos < 20) {
          counts[pos] = (counts[pos] || 0) + 1;
          if (counts[pos] > 1) {
            console.error(`Overlap bug: ${color} has multiple pieces on square #${pos}`);
          }
        }
      });
    }
    checkOverlap(whitePieces, "White");
    checkOverlap(blackPieces, "Black");
  }

  /***** Drawing *****/
  // We'll create a fancy tile gradient for squares, plus a star/rosette if needed.
  function drawBoard() {
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    boardSquares.forEach((sq, i) => {
      // Create a gold–blue radial gradient for the square
      const grad = ctx.createLinearGradient(sq.x, sq.y, sq.x+sq.w, sq.y+sq.h);
      grad.addColorStop(0, "#e6c87d"); // gold
      grad.addColorStop(1, "#4e6fa3"); // bluish

      ctx.fillStyle = grad;
      ctx.fillRect(sq.x, sq.y, SQUARE_SIZE, SQUARE_SIZE);

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeRect(sq.x, sq.y, SQUARE_SIZE, SQUARE_SIZE);

      // If rosette, draw a fancy star pattern in the center
      if (sq.rosette) {
        ctx.save();
        ctx.translate(sq.x + SQUARE_SIZE/2, sq.y + SQUARE_SIZE/2);

        // Outer circle
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fillStyle = "red";
        ctx.fill();

        // Star lines
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let arm=0; arm<8; arm++){
          ctx.moveTo(0,0);
          let angle = (Math.PI*2)* (arm/8);
          ctx.lineTo(Math.cos(angle)*15, Math.sin(angle)*15);
        }
        ctx.stroke();

        ctx.restore();
      }
    });
  }

  // Make the pieces fancy: a radial gradient plus a drop shadow effect
  function drawPieces() {
    // White pieces => gradient from white to light gray with a black border
    whitePieces.forEach(pos => {
      if (pos < 0 || pos >= 20) return;
      let sq = boardSquares[pos];
      let centerX = sq.x + SQUARE_SIZE/2;
      let centerY = sq.y + SQUARE_SIZE/2;

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      let grad = ctx.createRadialGradient(centerX-5, centerY-5, 5, centerX, centerY, 25);
      grad.addColorStop(0, "#ffffff");
      grad.addColorStop(1, "#d0d0d0");

      ctx.beginPath();
      ctx.arc(centerX, centerY, 22, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    });

    // Black pieces => gradient from dark gray to black with a white border
    blackPieces.forEach(pos => {
      if (pos < 0 || pos >= 20) return;
      let sq = boardSquares[pos];
      let centerX = sq.x + SQUARE_SIZE/2;
      let centerY = sq.y + SQUARE_SIZE/2;

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;

      let grad = ctx.createRadialGradient(centerX-5, centerY-5, 5, centerX, centerY, 25);
      grad.addColorStop(0, "#666666");
      grad.addColorStop(1, "#000000");

      ctx.beginPath();
      ctx.arc(centerX, centerY, 22, 0, Math.PI*2);
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    });
  }

  function drawUI() {
    // White bar at bottom for turn/dice info
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, canvasHeight - 30, canvasWidth, 30);

    ctx.fillStyle = "#000";
    ctx.font = "16px sans-serif";
    let txt = `Turn: ${currentTurn === "w" ? "White" : "Black"}. `;
    if (currentTurn === humanColor && !diceRolled) {
      txt += "Click 'Roll Dice' or press [R].";
    } else if (diceRolled) {
      txt += `Dice: ${currentDiceRoll}. Select a piece.`;
    }
    ctx.fillText(txt, 10, canvasHeight - 10);
  }

  function redrawPlayScreen() {
    drawBoard();
    drawPieces();
    drawUI();
  }

  /***** Game Logic *****/
  function getValidMove(piecePos, diceValue, ownPieces, oppPieces) {
    if (diceValue === 0) return null;
    let newPos = (piecePos === -1) ? 0 : piecePos + diceValue;
    if (newPos > 20) return null; // overshoot

    // Can't land on a square occupied by own piece
    if (newPos < 20 && ownPieces.includes(newPos)) return null;

    // If capturing an opponent on a rosette => not allowed
    if (newPos < 20 && oppPieces.includes(newPos)) {
      if (boardSquares[newPos].rosette) return null;
    }

    return newPos;
  }

  function getMoveOptions(diceValue) {
    let options = [];
    if (currentTurn === "w") {
      whitePieces.forEach((pos, idx) => {
        let target = getValidMove(pos, diceValue, whitePieces, blackPieces);
        if (target !== null) {
          options.push({ pieceIndex: idx, newPos: target });
        }
      });
    } else {
      blackPieces.forEach((pos, idx) => {
        let target = getValidMove(pos, diceValue, blackPieces, whitePieces);
        if (target !== null) {
          options.push({ pieceIndex: idx, newPos: target });
        }
      });
    }
    return options;
  }

  function executeMove(pieceIndex, targetPos) {
    try {
      let ownPieces = (currentTurn === "w") ? whitePieces : blackPieces;
      let oppPieces = (currentTurn === "w") ? blackPieces : whitePieces;

      ownPieces[pieceIndex] = targetPos;

      // Capture if landing on opponent (and not rosette)
      if (targetPos < 20) {
        let oppIdx = oppPieces.indexOf(targetPos);
        if (oppIdx !== -1) {
          oppPieces[oppIdx] = -1;
          if (debugMode) {
            console.log(`${currentTurn === "w" ? "White" : "Black"} captured an opponent on #${targetPos}`);
          }
        }
      }
      if (debugMode) checkForBugs();

      // Rosette => extra turn
      if (targetPos < 20 && boardSquares[targetPos].rosette) {
        extraTurn = true;
      } else {
        extraTurn = false;
      }

      // Check if all pieces finished => game over
      let finishedCount = ownPieces.filter(p => p === 20).length;
      if (finishedCount === NUM_PIECES) {
        gameState = "gameover";
        gameOverText.textContent = (currentTurn === humanColor) ? "You Win!" : "You Lose!";
      }

      // Switch turn unless extra turn or game ended
      if (!extraTurn && gameState === "playing") {
        currentTurn = (currentTurn === "w") ? "b" : "w";
      }
      diceRolled = false;
      currentDiceRoll = 0;
    } catch (err) {
      console.error("Error in executeMove:", err);
    }
  }

  function handleBoardClick(e) {
    if (gameState !== "playing") return;
    if (currentTurn !== humanColor) return;
    if (!diceRolled) return;

    let rect = canvas.getBoundingClientRect();
    let mx = e.clientX - rect.left, my = e.clientY - rect.top;

    let ownPieces = (currentTurn === "w") ? whitePieces : blackPieces;
    for (let i = 0; i < ownPieces.length; i++) {
      let pos = ownPieces[i];
      if (pos < 0 || pos >= 20) continue;
      let sq = boardSquares[pos];
      let centerX = sq.x + SQUARE_SIZE/2;
      let centerY = sq.y + SQUARE_SIZE/2;
      let dx = mx - centerX, dy = my - centerY;
      if (Math.sqrt(dx*dx + dy*dy) <= 22) {
        // Check if there's a valid move for this piece
        let moves = getMoveOptions(currentDiceRoll);
        let moveObj = moves.find(m => m.pieceIndex === i);
        if (moveObj) {
          executeMove(i, moveObj.newPos);
          redrawPlayScreen();
          return;
        }
      }
    }
  }

  function humanRollDice() {
    if (gameState !== "playing") return;
    if (currentTurn !== humanColor) return;
    if (diceRolled) return;

    currentDiceRoll = rollDice();
    diceRolled = true;
    if (debugMode) {
      console.log(`Human rolled: ${currentDiceRoll}`);
    }
    let moves = getMoveOptions(currentDiceRoll);
    if (moves.length === 0) {
      // No valid moves => pass turn
      diceRolled = false;
      currentDiceRoll = 0;
      currentTurn = (currentTurn === "w") ? "b" : "w";
    }
    redrawPlayScreen();
  }

  function aiMove() {
    if (gameState !== "playing") return;
    if (currentTurn === humanColor) return;
    aiThinking = true;
    loadingOverlay.style.display = "flex";

    setTimeout(() => {
      currentDiceRoll = rollDice();
      diceRolled = true;
      if (debugMode) {
        console.log(`AI (${currentTurn === "w" ? "White" : "Black"}) rolled: ${currentDiceRoll}`);
      }
      let moves = getMoveOptions(currentDiceRoll);
      if (moves.length > 0) {
        let pick = moves[Math.floor(Math.random() * moves.length)];
        executeMove(pick.pieceIndex, pick.newPos);
      } else {
        diceRolled = false;
        currentDiceRoll = 0;
        currentTurn = (currentTurn === "w") ? "b" : "w";
      }
      aiThinking = false;
      loadingOverlay.style.display = "none";
      redrawPlayScreen();
    }, 1500);
  }

  function mainLoop() {
    if (gameState === "playing") {
      redrawPlayScreen();
      // Show roll button if it's human turn & dice not rolled
      if (currentTurn === humanColor && !diceRolled) {
        rollDiceBtn.style.display = "block";
      } else {
        rollDiceBtn.style.display = "none";
      }
      // AI turn?
      if (currentTurn !== humanColor && !diceRolled && !aiThinking) {
        aiMove();
      }
    }
    requestAnimationFrame(mainLoop);
  }

  /***** Overlays & Navigation *****/
  function hideAllScreens() {
    menuScreen.style.display = "none";
    instructionsScreen.style.display = "none";
    sideScreen.style.display = "none";
    gameOverScreen.style.display = "none";
  }
  function showMenu() {
    hideAllScreens();
    gameState = "menu";
    menuScreen.style.display = "flex";
  }
  function showInstructions() {
    hideAllScreens();
    gameState = "instructions";
    instructionsScreen.style.display = "flex";
  }
  function showSideSelect() {
    hideAllScreens();
    gameState = "selectSide";
    sideScreen.style.display = "flex";
  }
  function startPlaying() {
    hideAllScreens();
    gameState = "playing";
    initPieces();
    currentTurn = "w"; // White always starts
    diceRolled = false;
    currentDiceRoll = 0;
    extraTurn = false;
  }
  function showGameOver() {
    hideAllScreens();
    gameState = "gameover";
    gameOverScreen.style.display = "flex";
  }

  // Button / Keyboard
  document.getElementById("newGameBtn").onclick = () => showSideSelect();
  document.getElementById("instructionsBtn").onclick = () => showInstructions();
  document.getElementById("whiteSideBtn").onclick = () => {
    humanColor = "w";
    startPlaying();
  };
  document.getElementById("blackSideBtn").onclick = () => {
    humanColor = "b";
    startPlaying();
  };
  document.getElementById("gameOverNewGameBtn").onclick = () => showSideSelect();

  rollDiceBtn.addEventListener("click", humanRollDice);

  document.addEventListener("keydown", (e) => {
    const key = e.key.toLowerCase();
    if (gameState === "selectSide") {
      if (key === "w") document.getElementById("whiteSideBtn").click();
      else if (key === "b") document.getElementById("blackSideBtn").click();
    } else if (gameState === "playing") {
      if (key === "r" && currentTurn === humanColor && !diceRolled) {
        humanRollDice();
      } else if (key === "m") {
        initPieces();
        showMenu();
      }
    } else if (["instructions","gameover"].includes(gameState)) {
      if (key === "m") {
        initPieces();
        showMenu();
      }
    }
  });

  canvas.addEventListener("mousedown", handleBoardClick);

  function startAll() {
    showMenu();
    requestAnimationFrame(mainLoop);
  }
  window.addEventListener("load", startAll);
</script>
</body>
</html>
