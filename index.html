<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented: Royal Game of Ur (Old-Fashioned Look)</title>
  <!-- Dummy favicon -->
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    body {
      margin: 0; padding: 0;
      background: #fafafa;
      font-family: sans-serif;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
      text-align: center;
      font-family: "Papyrus", cursive, serif; /* or another “old” font */
    }
    #gameContainer {
      position: relative;
      width: 1020px;
      max-width: 100%;
      padding: 20px;
      box-sizing: border-box;
      background: #fff;
      margin-bottom: 20px;
      border: 4px double #8b4513; /* old-fashioned double border */
      border-radius: 6px;
    }
    canvas {
      display: block;
      background: #f5f2e8; /* off-white parchment color for canvas background */
      margin: auto;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button,
    #controls input {
      font-size: 16px;
      padding: 6px 10px;
      margin: 4px;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      background: rgba(255,255,255,0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      text-align: center;
      z-index: 10;
    }
    button {
      font-size: 18px;
      margin: 10px;
      padding: 10px 20px;
      cursor: pointer;
      font-family: "Papyrus", cursive, serif;
    }
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: #fff;
      font-size: 24px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 1000;
    }
    .spinner {
      border: 8px solid rgba(255,255,255,0.3);
      border-top: 8px solid #fff;
      border-radius: 50%;
      width: 60px; height: 60px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #logo {
      position: fixed;
      bottom: 10px;
      right: 10px;
      max-width: 100px;
      z-index: 2000;
    }
  </style>
</head>
<body>

<div id="gameContainer">
  <!-- MENU SCREEN -->
  <div id="menuScreen" class="overlayScreen" style="display:flex;">
    <h1>Another Product Invented<br>Royal Game of Ur</h1>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS SCREEN -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>How to Play</strong></p>
    <p>
      1) Roll dice or set a custom dice.<br>
      2) Click on one of your 7 pieces (above/below the board if off-board) to move it.<br>
      3) You cannot capture on a rosette; exact roll is needed to exit at position 20.<br>
      4) This board is styled to look old-fashioned—enjoy!
    </p>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- SIDE SELECTION SCREEN -->
  <div id="sideScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White (Go First) [W]</button>
    <button id="blackSideBtn">Black (Go Second) [B]</button>
    <p>You can also press W or B on your keyboard.</p>
  </div>

  <!-- GAME OVER SCREEN -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <button id="gameOverNewGameBtn">New Game</button>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- 1000×600 canvas -->
  <canvas id="gameCanvas" width="1000" height="600"></canvas>
</div>

<!-- Controls below the board -->
<div id="controls">
  <button id="rollDiceBtn">Roll Dice</button>
  <label for="customDiceInput">Custom Dice:</label>
  <input type="number" id="customDiceInput" min="0" max="4" value="0">
  <button id="setCustomDiceBtn">Set Dice</button>
  <div id="pieceCountDisplay" style="margin-top:8px; font-size:16px;"></div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay">
  <div class="spinner"></div>
  <p>Thinking...</p>
</div>

<!-- Optional Logo -->
<img id="logo" src="logo.png" alt="Logo">

<script>
/***********************************
 * 1) Canvas & Board Coordinates
 **********************************/
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const canvasWidth = canvas.width;   // 1000
const canvasHeight = canvas.height; // 600

// Each square is 50×50
const SQUARE_SIZE = 50;
const boardWidth = 400, boardHeight = 150;
const boardMarginX = (canvasWidth - boardWidth)/2; // e.g. 300
const boardMarginY = (canvasHeight - boardHeight)/2; // e.g. 225

// We'll define 20 squares physically
const boardSquares = [
  // top row
  { x:0,   y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:200, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:250, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:350, y:0,   w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },

  // middle row
  { x:0,   y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:100, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:150, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:200, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  },
  { x:250, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:350, y:50,  w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },

  // bottom row
  { x:0,   y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:50,  y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:200, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:250, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:300, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:false },
  { x:350, y:100, w:SQUARE_SIZE, h:SQUARE_SIZE, rosette:true  }
];

// White path (14 squares)
const whitePath = [2,3,4,5, 13,12,11,10,9,8,7,6, 0,1];
// Black path (14 squares)
const blackPath = [16,17,18,19, 13,12,11,10,9,8,7,6, 14,15];

let gameState = "menu"; 
let humanColor = null;  
let currentTurn = null; 
let currentDiceRoll = 0;
let diceRolled = false;
let extraTurn = false;
let aiThinking = false;
const debugMode = true;

const NUM_PIECES = 7;
let whitePieces = [], blackPieces = [];
let lastMove = null; // { fromPos, toPos, color }

// NEW: We'll store a short dice message to show “White rolled X” or “Black rolled X.”
let diceMessage = ""; // updated each time someone rolls

/***********************************
 * 2) Off-board & On-board Coordinates
 **********************************/
function getPieceCoords(color, pieceIndex, pos) {
  if(pos>=0 && pos<20) {
    let sq=boardSquares[pos];
    return {
      x: sq.x + boardMarginX + sq.w/2,
      y: sq.y + boardMarginY + sq.h/2
    };
  }
  if(pos===20) {
    let baseY = (color==='w')? 100 : 300;
    return {
      x: boardMarginX + boardWidth + 80,
      y: boardMarginY + baseY + pieceIndex*30
    };
  }
  if(pos===-1) {
    if(color==='w') {
      return {
        x: boardMarginX + pieceIndex*(SQUARE_SIZE+5) + 20,
        y: boardMarginY - 60
      };
    } else {
      return {
        x: boardMarginX + pieceIndex*(SQUARE_SIZE+5) + 20,
        y: boardMarginY + boardHeight + 60
      };
    }
  }
  return { x:0, y:0 };
}
function getHighlightBox(color, pieceIndex, pos) {
  let c = getPieceCoords(color, pieceIndex, pos);
  return { x: c.x-20, y: c.y-20, w:40, h:40 };
}

/***********************************
 * 3) Init & Debug
 **********************************/
function initPieces(){
  whitePieces = Array(NUM_PIECES).fill(-1);
  blackPieces = Array(NUM_PIECES).fill(-1);
  lastMove = null;
  diceMessage = "";
}
function rollDice(){
  let total=0;
  for(let i=0; i<4; i++){
    total += Math.floor(Math.random()*2);
  }
  return total;
}
function checkForBugs(){
  function checkOverlap(pieces, color){
    const c={};
    pieces.forEach(pos=>{
      if(pos>=0 && pos<20){
        c[pos]=(c[pos]||0)+1;
        if(c[pos]>1){
          console.error(`Overlap bug: ${color} has multiple pieces on #${pos}`);
        }
      }
    });
  }
  checkOverlap(whitePieces,"White");
  checkOverlap(blackPieces,"Black");
}

/***********************************
 * 4) Path Logic
 **********************************/
function getPath(color){
  return (color==='w')? whitePath : blackPath;
}
function getValidMove(piecePos, diceValue, color){
  if(diceValue===0) return null;
  let path = getPath(color);
  let pathIndex = -1; 
  if(piecePos>=0 && piecePos<20){
    let idx= path.indexOf(piecePos);
    if(idx===-1){
      if(debugMode) console.warn(`Piece pos ${piecePos} not in path for color=${color}`);
      return null;
    }
    pathIndex= idx;
  } else if(piecePos===20){
    return null; 
  }
  let newIndex= pathIndex + diceValue;
  if(newIndex> path.length) return null; 
  if(newIndex=== path.length) return 20; 
  return path[newIndex];
}
function canLandOn(pos, color){
  const own=(color==='w')? whitePieces: blackPieces;
  const opp=(color==='w')? blackPieces: whitePieces;
  if(pos<20 && own.includes(pos)) return false; 
  if(pos<20 && opp.includes(pos) && boardSquares[pos].rosette) return false;
  return true;
}
function getMoveOptions(diceValue, color){
  let res=[];
  const own=(color==='w')? whitePieces: blackPieces;
  own.forEach((pos,i)=>{
    if(pos===20) return; 
    let target = getValidMove(pos,diceValue,color);
    if(target!==null && canLandOn(target,color)){
      res.push({ pieceIndex:i, fromPos: pos, toPos: target });
    }
  });
  return res;
}

/***********************************
 * 5) Move Execution & Highlight
 **********************************/
function executeMove(pieceIndex, toPos, color){
  try{
    const own=(color==='w')? whitePieces: blackPieces;
    const opp=(color==='w')? blackPieces: whitePieces;
    let fromPos= own[pieceIndex];
    own[pieceIndex]= toPos;

    // capture
    if(toPos<20){
      let oppIdx= opp.indexOf(toPos);
      if(oppIdx!==-1){
        opp[oppIdx]=-1;
        if(debugMode) console.log(`${color==='w'?"White":"Black"} captured an opponent on #${toPos}`);
      }
    }
    if(debugMode) checkForBugs();

    lastMove = { fromPos, toPos, color, pieceIndex };

    if(toPos<20 && boardSquares[toPos].rosette){
      extraTurn=true;
    } else {
      extraTurn=false;
    }
    let finishedCount= own.filter(p=>p===20).length;
    if(finishedCount===NUM_PIECES){
      gameState="gameover";
      document.getElementById("gameOverText").textContent= (color===humanColor)? "You Win!" : "You Lose!";
    }
    if(!extraTurn && gameState==="playing"){
      currentTurn=(currentTurn==='w')?'b':'w';
      // Clear diceMessage after the turn changes if you want it to vanish. 
      // Or you can keep it around until next roll. We'll keep it around.
    }
    diceRolled=false; currentDiceRoll=0;
  } catch(err){
    console.error("Error in executeMove:", err);
  }
}

function highlightLastMove(){
  if(!lastMove) return;
  let { fromPos, toPos, color, pieceIndex } = lastMove;
  // from
  if(fromPos===-1 || fromPos===20){
    let box= getHighlightBox(color, pieceIndex, fromPos);
    ctx.fillStyle="rgba(255,255,0,0.5)";
    ctx.fillRect(box.x, box.y, box.w, box.h);
  } else if(fromPos>=0 && fromPos<20){
    let sq=boardSquares[fromPos];
    let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
    ctx.fillStyle="rgba(255,255,0,0.5)";
    ctx.fillRect(x,y,sq.w,sq.h);
  }
  // to
  if(toPos===-1 || toPos===20){
    let box= getHighlightBox(color, pieceIndex, toPos);
    ctx.fillStyle="rgba(0,128,255,0.5)";
    ctx.fillRect(box.x, box.y, box.w, box.h);
  } else if(toPos>=0 && toPos<20){
    let sq=boardSquares[toPos];
    let x=sq.x+boardMarginX, y=sq.y+boardMarginY;
    ctx.fillStyle="rgba(0,128,255,0.5)";
    ctx.fillRect(x,y, sq.w,sq.h);
  }
}

/***********************************
 * 6) Drawing
 **********************************/
// star function for rosettes
function drawStar(cx, cy, spikes, outerRadius, innerRadius, fillColor, strokeColor, lineWidth){
  let angle = Math.PI / spikes;
  ctx.beginPath();
  for(let i=0; i<2*spikes; i++){
    let r = (i%2===0)? outerRadius : innerRadius;
    let px = cx + r*Math.cos(i*angle);
    let py = cy + r*Math.sin(i*angle);
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.fillStyle= fillColor;
  ctx.fill();
  if(strokeColor){
    ctx.strokeStyle= strokeColor;
    ctx.lineWidth= lineWidth;
    ctx.stroke();
  }
}

function drawFancySquare(x, y, w, h){
  let cx = x + w/2, cy = y + h/2;
  let grad= ctx.createRadialGradient(cx, cy, 5, cx, cy, 45);
  grad.addColorStop(0, "#c2a676"); 
  grad.addColorStop(0.5, "#8b6f47");
  grad.addColorStop(1, "#6b4e2e");
  ctx.fillStyle=grad;
  ctx.fillRect(x,y,w,h);
  ctx.strokeStyle="#000"; 
  ctx.lineWidth=1.5;
  ctx.strokeRect(x,y,w,h);
}

function drawBoard(){
  ctx.clearRect(0,0, canvasWidth, canvasHeight);
  highlightLastMove();

  boardSquares.forEach((sq,i)=>{
    let drawX = sq.x+boardMarginX, drawY= sq.y+boardMarginY;
    drawFancySquare(drawX, drawY, sq.w, sq.h);
    if(sq.rosette){
      ctx.save();
      ctx.translate(drawX+ sq.w/2, drawY+ sq.h/2);
      drawStar(0,0,8,10,5,"#e94","#fff",2);
      ctx.restore();
    }
  });
}

function drawPieces(){
  // White
  whitePieces.forEach((pos,i)=>{
    let c= getPieceCoords('w', i, pos);
    ctx.save();
    ctx.shadowColor="rgba(0,0,0,0.4)";
    ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
    let grad=ctx.createRadialGradient(c.x-5,c.y-5,5, c.x,c.y,18);
    grad.addColorStop(0,"#fffaf0");
    grad.addColorStop(1,"#dcd0ba");
    ctx.beginPath();
    ctx.arc(c.x,c.y,18,0,Math.PI*2);
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle="#000"; ctx.lineWidth=2;
    ctx.stroke();
    ctx.restore();
  });
  // Black
  blackPieces.forEach((pos,i)=>{
    let c= getPieceCoords('b', i, pos);
    ctx.save();
    ctx.shadowColor="rgba(0,0,0,0.5)";
    ctx.shadowBlur=6; ctx.shadowOffsetX=3; ctx.shadowOffsetY=3;
    let grad=ctx.createRadialGradient(c.x-5,c.y-5,5, c.x,c.y,18);
    grad.addColorStop(0,"#666666");
    grad.addColorStop(1,"#000000");
    ctx.beginPath();
    ctx.arc(c.x,c.y,18,0,Math.PI*2);
    ctx.fillStyle=grad; ctx.fill();
    ctx.strokeStyle="#fff"; ctx.lineWidth=2;
    ctx.stroke();
    ctx.restore();
  });
}

function drawUI(){
  ctx.fillStyle="#f5f2e8";
  ctx.fillRect(0, canvasHeight-30, canvasWidth, 30);
  ctx.strokeStyle="#000";
  ctx.strokeRect(0, canvasHeight-30, canvasWidth, 30);

  ctx.fillStyle="#000";
  ctx.font="16px 'Papyrus', serif";
  let txt = `Turn: ${currentTurn==='w'?"White":"Black"}. `;
  // If there's a diceMessage, we append it
  if(diceMessage) {
    txt += diceMessage + " "; // e.g. "White rolled 3"
  }
  const whiteOff=whitePieces.filter(p=>p===-1).length;
  const blackOff=blackPieces.filter(p=>p===-1).length;
  txt += `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
  ctx.fillText(txt, 10, canvasHeight-10);
}

function redrawPlayScreen(){
  drawBoard();
  drawPieces();
  drawUI();
}

/***********************************
 * 7) Interaction & Moves
 **********************************/
function handleBoardClick(e){
  if(gameState!=="playing") return;
  if(currentTurn!==humanColor) return;
  if(!diceRolled){
    if(debugMode) console.warn("Must roll dice before moving a piece!");
    return;
  }
  let moves=getMoveOptions(currentDiceRoll, currentTurn);
  if(moves.length===0 && debugMode){
    console.warn("No valid moves => pass turn!");
  }
  let rect=canvas.getBoundingClientRect();
  let mx=e.clientX-rect.left, my=e.clientY-rect.top;
  const own=(currentTurn==='w')? whitePieces : blackPieces;
  for(let i=0; i<own.length; i++){
    let pos=own[i];
    if(pos===20) continue;
    let c= getPieceCoords(currentTurn, i, pos);
    let dx=mx-c.x, dy=my-c.y;
    if(Math.sqrt(dx*dx+dy*dy)<=18){
      let found = moves.find(m=>m.pieceIndex===i);
      if(!found){
        if(debugMode) console.warn(`Piece #${i} can't move with dice=${currentDiceRoll}`);
        return;
      }
      executeMove(i, found.toPos, currentTurn);
      redrawPlayScreen();
      return;
    }
  }
}

/***********************************
 * 8) Rolling Dice & AI
 **********************************/
// We'll update diceMessage each time someone rolls
function setDiceMessage(color, diceVal) {
  if(color==='w') diceMessage = `White rolled ${diceVal}`;
  else if(color==='b') diceMessage = `Black rolled ${diceVal}`;
}

function humanRollDice(){
  if(gameState!=="playing") return;
  if(currentTurn!==humanColor) return;
  if(diceRolled){
    if(debugMode) console.warn("Already rolled dice this turn!");
    return;
  }
  currentDiceRoll=rollDice();
  diceRolled=true;
  // set dice message
  setDiceMessage(currentTurn, currentDiceRoll);

  if(debugMode) console.log(`Human rolled: ${currentDiceRoll}`);
  let options=getMoveOptions(currentDiceRoll, currentTurn);
  if(options.length===0){
    if(debugMode) console.warn("No valid moves => pass turn to opponent.");
    diceRolled=false; currentDiceRoll=0;
    currentTurn=(currentTurn==='w')?'b':'w';
  }
  redrawPlayScreen();
}

function aiMove(){
  if(gameState!=="playing") return;
  if(currentTurn===humanColor) return;
  aiThinking=true;
  document.getElementById("loadingOverlay").style.display="flex";
  setTimeout(()=>{
    currentDiceRoll=rollDice();
    diceRolled=true;
    // set dice message
    setDiceMessage(currentTurn, currentDiceRoll);

    if(debugMode) console.log(`AI (${currentTurn==='w'?'White':'Black'}) rolled: ${currentDiceRoll}`);
    let options=getMoveOptions(currentDiceRoll, currentTurn);
    if(options.length>0){
      let pick=options[Math.floor(Math.random()*options.length)];
      executeMove(pick.pieceIndex, pick.toPos, currentTurn);
    } else {
      if(debugMode) console.warn("AI has no valid moves => pass turn!");
      diceRolled=false; currentDiceRoll=0;
      currentTurn=(currentTurn==='w')?'b':'w';
    }
    aiThinking=false;
    document.getElementById("loadingOverlay").style.display="none";
    redrawPlayScreen();
  },1500);
}

/***********************************
 * 9) Main Loop
 **********************************/
function mainLoop(){
  if(gameState==="playing"){
    redrawPlayScreen();
    if(currentTurn===humanColor && !diceRolled){
      document.getElementById("rollDiceBtn").style.display="inline-block";
    } else {
      document.getElementById("rollDiceBtn").style.display="none";
    }
    if(currentTurn!==humanColor && !diceRolled && !aiThinking){
      aiMove();
    }
    const whiteOff=whitePieces.filter(p=>p===-1).length;
    const blackOff=blackPieces.filter(p=>p===-1).length;
    document.getElementById("pieceCountDisplay").textContent=
      `White off-board: ${whiteOff} | Black off-board: ${blackOff}`;
  }
  requestAnimationFrame(mainLoop);
}

/***********************************
 * 10) Overlays & Navigation
 **********************************/
function hideAllScreens(){
  document.getElementById("menuScreen").style.display="none";
  document.getElementById("instructionsScreen").style.display="none";
  document.getElementById("sideScreen").style.display="none";
  document.getElementById("gameOverScreen").style.display="none";
}
function showMenu(){
  hideAllScreens();
  gameState="menu";
  document.getElementById("menuScreen").style.display="flex";
}
function showInstructions(){
  hideAllScreens();
  gameState="instructions";
  document.getElementById("instructionsScreen").style.display="flex";
}
function showSideSelect(){
  hideAllScreens();
  gameState="selectSide";
  document.getElementById("sideScreen").style.display="flex";
}
function startPlaying(){
  hideAllScreens();
  gameState="playing";
  initPieces();
  currentTurn="w";
  diceRolled=false; currentDiceRoll=0; extraTurn=false;
}
function showGameOver(){
  hideAllScreens();
  gameState="gameover";
  document.getElementById("gameOverScreen").style.display="flex";
}

/***********************************
 * 11) Buttons & Keyboard
 **********************************/
document.getElementById("newGameBtn").onclick=()=>showSideSelect();
document.getElementById("instructionsBtn").onclick=()=>showInstructions();
document.getElementById("whiteSideBtn").onclick=()=>{
  humanColor='w'; startPlaying();
};
document.getElementById("blackSideBtn").onclick=()=>{
  humanColor='b'; startPlaying();
};
document.getElementById("gameOverNewGameBtn").onclick=()=>showSideSelect();
document.getElementById("rollDiceBtn").addEventListener("click", humanRollDice);

// custom dice
document.getElementById("setCustomDiceBtn").addEventListener("click",()=>{
  const val=parseInt(document.getElementById("customDiceInput").value,10);
  if(!isNaN(val) && val>=0 && val<=4){
    currentDiceRoll=val;
    diceRolled=true;
    // set dice message
    setDiceMessage(currentTurn, currentDiceRoll);

    if(debugMode) console.log(`Custom dice set to: ${currentDiceRoll}`);
    redrawPlayScreen();
  }
});

document.addEventListener("keydown",(e)=>{
  const key=e.key.toLowerCase();
  if(gameState==="selectSide"){
    if(key==="w") document.getElementById("whiteSideBtn").click();
    else if(key==="b") document.getElementById("blackSideBtn").click();
  } else if(gameState==="playing"){
    if(key==="r" && currentTurn===humanColor && !diceRolled){
      humanRollDice();
    } else if(key==="m"){
      initPieces();
      showMenu();
    }
  } else if(["instructions","gameover"].includes(gameState)){
    if(key==="m"){
      initPieces();
      showMenu();
    }
  }
});

canvas.addEventListener("mousedown", handleBoardClick);

function startAll(){
  showMenu();
  requestAnimationFrame(mainLoop);
}
window.addEventListener("load", startAll);

/***********************************
 * Star Helper
 **********************************/
function drawStar(cx, cy, spikes, outerRadius, innerRadius, fillColor, strokeColor, lineWidth){
  let angle = Math.PI / spikes;
  ctx.beginPath();
  for(let i=0; i<2*spikes; i++){
    let r = (i%2===0)? outerRadius : innerRadius;
    let px = cx + r*Math.cos(i*angle);
    let py = cy + r*Math.sin(i*angle);
    if(i===0) ctx.moveTo(px,py);
    else ctx.lineTo(px,py);
  }
  ctx.closePath();
  ctx.fillStyle= fillColor;
  ctx.fill();
  if(strokeColor){
    ctx.strokeStyle= strokeColor;
    ctx.lineWidth= lineWidth;
    ctx.stroke();
  }
}
</script>
</body>
</html>
